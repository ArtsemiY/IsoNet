#!/usr/bin/env python3
import keras
from tifffile import imsave,imread
import numpy as np
from scipy.ndimage.interpolation import rotate
from keras.models import model_from_json
from mwr.util.toTile import reform3D,DataWrapper
from mwr.util import normalize

def rotate_before(real_data,direction):
    if direction == 'X' or direction =='x':
        return np.rot90(real_data, 1, (0,1))
    elif direction == 'Y' or direction =='y':
        return np.rot90(real_data, 1, (0,2))
    elif direction == 'Z' or direction == 'z':
        return np.rot90(real_data, 1, (1,2))
    else:
        return real_data
def rotate_after(out_data,direction):
    if direction == 'X' or direction =='x':
        return np.rot90(out_data, 1, (1,0))
    elif direction == 'Y' or direction =='y':
        return np.rot90(out_data, 1, (2,0))
    elif direction == 'Z' or direction == 'z':
        return np.rot90(out_data, 1, (2,1))
    else:
        return out_data


def predict2D(real_data, model_name, direction):
    real_data = np.expand_dims(real_data,axis=-1)
    rotated=rotate_before(real_data,direction)
    #imsave('xyz.tif',xyz_data)
    model=keras.models.load_model(model_name)
    predictData=model.predict(rotated,batch_size=32,verbose=1)
    #imsave('xyz_corrected.tif',outData)
    outData=rotate_after(predictData,direction)
    outData=outData.reshape(outData.shape[0:-1])
    return outData

def predict2D_yx(real_data,model_name):
    real_data = np.expand_dims(real_data,axis=-1)
    model=keras.models.load_model(model_name)
    outData=model.predict(real_data,batch_size=32,verbose=1)
    outData=np.squeeze(outData,axis=-1)
    return outData


def predict3D(real_data, model_name):
    data=np.expand_dims(real_data,axis=-1)
    reform_ins = reform3D(data)
    data = reform_ins.pad_and_crop()
    print('predict data.shape:',data.shape)
    model=keras.models.load_model(model_name)
    data_gene=DataWrapper(data,8)
    outData=model.predict_generator(data_gene,verbose=1)
    print(outData.shape)
    outData=reform_ins.restore_from_cubes(outData.reshape(outData.shape[0:-1]))

    return outData


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('real_data', type=str ,help='Data for predict')
    parser.add_argument('--model', type=str, default='weights_last.h5' ,help='Model to predict')
    parser.add_argument('--model_duel', type=str, default=None ,help='Model to predict')
    parser.add_argument('--outName', type=str, default='corrected_last1.tif', help='File name of corrected .tif file ')
    parser.add_argument('--dim', type=str, default='2D' ,help='dimension of data')
    parser.add_argument('--direc', type=str, default='XY', help='which face to predict')
    parser.add_argument('--ip', type=str, default=None, help='to specify working gpus' )
    args = parser.parse_args()
    import os
    if args.ip == '24':
        os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID"
        os.environ["CUDA_VISIBLE_DEVICES"]="1"  # specify which GPU(s) to be used
    real_data,ma,mi=normalize(imread(args.real_data))
    print('real_data shape:',real_data.shape)
    if args.dim=='2D':
        reform = reform3D(real_data)
        padded = reform.pad4times()
        if args.model_duel is not None:
            predicted = predict2D(padded, args.model,args.direc)
            predicted_duel = predict2D(padded, args.model_duel,args.direc)
            predicted = (predicted + predicted_duel)/2
        else:
            predicted = predict2D(padded, args.model,args.direc)
        outData = reform.cropback(predicted)
        outData = outData*(ma-mi)+mi
        outData=outData.astype(np.uint8)
    elif args.dim=='3D':
        outData=predict3D(real_data, args.model)
        outData = outData * (ma - mi) + mi
        outData = outData.astype(np.uint8)
    imsave(args.outName,outData)
    

